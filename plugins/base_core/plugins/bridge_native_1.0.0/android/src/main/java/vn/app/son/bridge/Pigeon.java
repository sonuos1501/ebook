// Autogenerated from Pigeon (v4.2.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package vn.app.son.bridge;

import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import io.flutter.embedding.engine.plugins.FlutterPlugin;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import io.flutter.plugin.common.StandardMessageCodec;

import java.io.ByteArrayOutputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * Generated class from Pigeon.
 */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RbasendantSuppression"})
public class Pigeon implements FlutterPlugin {

    @NonNull
    private static Map<String, Object> wrapError(@NonNull Throwable exception) {
        Map<String, Object> errorMap = new HashMap<>();
        errorMap.put("message", exception.toString());
        errorMap.put("code", exception.getClass().getSimpleName());
        errorMap.put("details", "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
        return errorMap;
    }

    public void onAttachedToEngine(FlutterPlugin.FlutterPluginBinding binding) {
        //nothing
    }

    public void onDetachedFromEngine(@NonNull FlutterPlugin.FlutterPluginBinding binding) {
        //nothing
    }

    /**
     * Generated interface from Pigeon that represents a handler of messages from Flutter.
     */
    public interface ReqApi {
        /**
         * The codec used by ReqApi.
         */
        static MessageCodec<Object> getCodec() {
            return ReqApiCodec.INSTANCE;
        }

        /**
         * Sets up an instance of `ReqApi` to handle messages through the `binaryMessenger`.
         */
        static void setup(BinaryMessenger binaryMessenger, ReqApi api) {
            {
                BasicMessageChannel<Object> channel = new BasicMessageChannel<>(binaryMessenger, "dev.flutter.pigeon.ReqApi.request", getCodec());
                if (api != null) {
                    channel.setMessageHandler((message, reply) -> {
                        Map<String, Object> wrapped = new HashMap<>();
                        try {
                            ArrayList<Object> args = (ArrayList<Object>) message;
                            Req requestArg = (Req) args.get(0);
                            if (requestArg == null) {
                                throw new NullPointerException("requestArg unexpectedly null.");
                            }
                            Res output = api.request(requestArg);
                            wrapped.put("result", output);
                        } catch (Error | RuntimeException exception) {
                            wrapped.put("error", wrapError(exception));
                        }
                        reply.reply(wrapped);
                    });
                } else {
                    channel.setMessageHandler(null);
                }
            }
        }

        @NonNull
        Res request(@NonNull Req request);
    }

    /**
     * Generated class from Pigeon that represents data sent in messages.
     */
    public static class Req {
        private @Nullable
        String key;
        private @Nullable
        Map<Object, Object> data;

        static @NonNull
        Req fromMap(@NonNull Map<String, Object> map) {
            Req pigeonResult = new Req();
            Object key = map.get("key");
            pigeonResult.setKey((String) key);
            Object data = map.get("data");
            pigeonResult.setData((Map<Object, Object>) data);
            return pigeonResult;
        }

        public @Nullable
        String getKey() {
            return key;
        }

        public void setKey(@Nullable String setterArg) {
            this.key = setterArg;
        }

        public @Nullable
        Map<Object, Object> getData() {
            return data;
        }

        public void setData(@Nullable Map<Object, Object> setterArg) {
            this.data = setterArg;
        }

        @NonNull
        Map<String, Object> toMap() {
            Map<String, Object> toMapResult = new HashMap<>();
            toMapResult.put("key", key);
            toMapResult.put("data", data);
            return toMapResult;
        }

        public static final class Builder {
            private @Nullable
            String key;
            private @Nullable
            Map<Object, Object> data;

            public @NonNull
            Builder setKey(@Nullable String setterArg) {
                this.key = setterArg;
                return this;
            }

            public @NonNull
            Builder setData(@Nullable Map<Object, Object> setterArg) {
                this.data = setterArg;
                return this;
            }

            public @NonNull
            Req build() {
                Req pigeonReturn = new Req();
                pigeonReturn.setKey(key);
                pigeonReturn.setData(data);
                return pigeonReturn;
            }
        }
    }

    /**
     * Generated class from Pigeon that represents data sent in messages.
     */
    public static class Res {
        private @Nullable
        String key;
        private @Nullable
        Map<Object, Object> data;

        static @NonNull
        Res fromMap(@NonNull Map<String, Object> map) {
            Res pigeonResult = new Res();
            Object key = map.get("key");
            pigeonResult.setKey((String) key);
            Object data = map.get("data");
            pigeonResult.setData((Map<Object, Object>) data);
            return pigeonResult;
        }

        public @Nullable
        String getKey() {
            return key;
        }

        public void setKey(@Nullable String setterArg) {
            this.key = setterArg;
        }

        public @Nullable
        Map<Object, Object> getData() {
            return data;
        }

        public void setData(@Nullable Map<Object, Object> setterArg) {
            this.data = setterArg;
        }

        @NonNull
        Map<String, Object> toMap() {
            Map<String, Object> toMapResult = new HashMap<>();
            toMapResult.put("key", key);
            toMapResult.put("data", data);
            return toMapResult;
        }

        public static final class Builder {
            private @Nullable
            String key;
            private @Nullable
            Map<Object, Object> data;

            public @NonNull
            Builder setKey(@Nullable String setterArg) {
                this.key = setterArg;
                return this;
            }

            public @NonNull
            Builder setData(@Nullable Map<Object, Object> setterArg) {
                this.data = setterArg;
                return this;
            }

            public @NonNull
            Res build() {
                Res pigeonReturn = new Res();
                pigeonReturn.setKey(key);
                pigeonReturn.setData(data);
                return pigeonReturn;
            }
        }
    }

    private static class ReqApiCodec extends StandardMessageCodec {
        public static final ReqApiCodec INSTANCE = new ReqApiCodec();

        private ReqApiCodec() {
        }

        @Override
        protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
            switch (type) {
                case (byte) 128:
                    return Req.fromMap((Map<String, Object>) readValue(buffer));

                case (byte) 129:
                    return Res.fromMap((Map<String, Object>) readValue(buffer));

                default:
                    return super.readValueOfType(type, buffer);

            }
        }

        @Override
        protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
            if (value instanceof Req) {
                stream.write(128);
                writeValue(stream, ((Req) value).toMap());
            } else if (value instanceof Res) {
                stream.write(129);
                writeValue(stream, ((Res) value).toMap());
            } else {
                super.writeValue(stream, value);
            }
        }
    }
}
